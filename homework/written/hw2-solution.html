1. )R-3.13 p.156
Describe and implement a recursive algorithm for finding the maximum element in an array A of n elements.
What is your running time and space usage? Implement your algorithm in Java.

public static int max( int [] A, int n ) {
  if ( n == 1 ) return A[ 0 ];
  int large = max( A, n - 1 );
  return ( large > A[ n - 1 ] ) ? large : A[ n - 1 ] 
}

Big-Oh: O(n)

Because depends on how many elements are in the array at worst we go through the entire
array if max last element

2. C-3.8 p.157 Decribe a recursive algorithm for reversing a singly linked list L, 
so that the ordering of the nodes becomes opposite of what it was before.

see solution in exclipse workbench

3. C-3.12 p.157 Describe in detail an algorithm for reversing a singly linked 
list L using only a constant amount of additional space and not using 
any recursion. Implement your algorithm in Java.

see solution in eclipse work bench

4.C-3.14 p.158
Describe and implement a recursive method for converting a string of digits into the integer
it represents. For example, "13531" represents the integer 13,531. 

see solution in eclipse work bench

5.C-3.15 p. 158
Describe a recursive algorithm that counts the number of nodes in singly linked list. What is the time 
complexity of your algorithm? Implement your algorithm in Java.

see solution in eclipse work bench

The time complexity is O(n) -> it depends on the numebr of elements in the list

6. C-3.17 p.158 
Write a short recursive Java method that finds the minimum and maximum values in an array of int values 
without using any loops. What is the time complexity of your algorithm?

see solution in eclipse work bench

Time complexit is O(n) -> worst case scenario array is order from smallest to highest

7.C-3.20 p. 158
Write a short recursive Java method that takes a character string s and output
its reverse. So for example, the reverse of "pots&pans" would be "snap&stop". 

see solution in eclipse workbench

8. C-4.12 p.198 Describe a method for finding both the minimum and maximum of n nunbers using 
fewer than 3n/2 comparisons. (Hints: First construct a group of candidate minimums and a group of 
candidate maximums.)

see solution in eclipse work bench

9.C-4.16 p.198
Let p(x) be a polynomial of degree n, that is, p(x) = S_i=0^n a_ix^i.

Describr a simple O(n^2) time method for computing p(x).

double evalPoly(int[] coefs, int[] pows, x) {
  double val = 0;
  for ( int i = 0, j = 0, maxCoefs = coefs.length, maxPows = pows.length;
	i < maxCoefs && j < maxPows; i++, j++ ) {
    val += coefs[ i ] * Math.pow( x, pows[ j ] );
  }
  return val;
}

Implement Horners Method

public static double polyEval(int[] coefficients, double x) {
    double accumulator = coefficients[ 0 ];
    for (int i = 1, max = coefficients.length; i < max; i++) {
	accumulator = (accumulator * x) + (double) coefficients[ i ];
    }
    return accumulator;
}

10. What is the running time complexity of the given function ?
        
      long func(long x, int n) {
	if ( n == 0 ) return 1 ;
	if ( n == 1 ) return x ;
	if ( n % 2 == 0 ) return func(x*x , n/2) ;
        else return x*func(x*x, n/2) ;
      }

Computer x^n

n = 0 return 1
n = 1 return x
n = even return (X^2)^(n/2)
n = odd return x((x^2)^(n/2))

decreasing by 1/2 is logarithmic

T(n) = {0, n = 0 or 1
       {2 + T(n/2), n = odd
       {1 + T(n/2), n = even

T(n) = {2 + T(n/2), n >= 2
       {0, n <= 1

T(n/2) = T((n/2)/2) + 2 = T(n/4) + 2 = T(n/2^2) + 2

T(n) = T(n/2) + 2 = T(n/2^2) + 2 + 2 = T(n/2^3) + 2 + 2 + 2 = 2 lg n = O(lg n)

2 lg(n) - > each iteration thre in a factor of 2, after
so many iterations you have 2 lg n

11. What is the running time complexity of the given function?
           int mystry(int n) {
                if ( n == 0 || n ==  1)  return 1 ;
                return mystry(n-1)*mystry(n-2) ;
           }

T(n) = {0, n = 0 or 1
       {1 + T(n - 1) + T(n - 2), n >= 2

This is worse than fibonacci

Theta(2^n) this is exponential

12. What is the running time complexity of the given function?
          int mystry(int n) {
                if  ( n == 0 ) return 0 ;
                return 1+ mystry(n/2) ;
          }

T(n) = {0, n = 0
       {2 + T(n/2), n > 0

this is logarithmic

O(log n)

13. For each of the following infix expressions, what is 
corresponding postfix expression?
  a. a*(b/c+d)
  b. a-(b/(c-d)*e+f)^g
  c. (a-b*c)/(d*e^f*g+h)
  d. ( a + b ) * c ^ (a - b) / (a + b * c)
  e. a ^ b / c ^ d * (a - b ) ^ c
  f. ( a * b - c / d + e ) + ( a - b - c - d * d ) / ( a + b * c )
  g. ( a + b ) * c ^ (a - b) ^ (a + b * c)

a. a*(b/c+d)

( a * ( ( b / c ) + d ) )
( a ( ( b c /) d +) *)
abc/d+*

b. a-(b/(c-d)*e+f)^g

( a - ( ( ( ( b / ( c - d ) ) * e ) + f ) ^ g ) )
( a ( ( ( ( b ( c d -) /) e *) f +) g ^) -)
abcd-/e*f+g^-

c. (a-b*c)/(d*e^f*g+h)

( ( a - ( b * c ) ) / ( ( ( d * ( e ^ f ) ) * g ) + h ) )
( ( a ( b c *) -) ( ( ( d ( e f ^) *) g *) h +) /)
abc*-def^*g*h+/

d. ( a + b ) * c ^ (a - b) / (a + b * c)

( ( ( a + b ) * ( c ^ ( a - b ) ) ) / ( a + ( b * c ) ) )
( ( ( a b +) ( c ( a b -) ^) *) ( a ( b c *) +) /)
ab+cab-^*abc*+/

e. a ^ b / c ^ d * (a - b ) ^ c
( ( ( a ^ b ) / ( c ^ d ) ) * ( ( a - b ) ^ c ) )
( ( ( a b ^) ( c d ^) /) ( ( a b -) c ^) *)
ab^cd^/ab-c^*

f. ( a * b - c / d + e ) + ( a - b - c - d * d ) / ( a + b * c )

( ( ( ( a * b ) - ( c / d ) ) + e ) + ( ( ( ( ( a - b ) - c ) - ( d * d ) ) ) / ( ( a + ( b * c ) ) ) ) )
( ( ( ( a b *) ( c d /) -) e +) ( ( ( ( ( a b -) c -) ( d d *) -) ) ( ( a ( b c *) +) ) /) +)
ab*cd/-e+ab-c-dd*-abc*+/+

g. ( a + b ) * c ^ (a - b) ^ (a + b * c)
( ( a + b ) * ( c ^ ( ( a - b ) ^ ( a + ( b * c ) ) ) ) )
( ( a b +) ( c ( ( a b -) ( a ( b c *) +) ^) ^) *)
ab+cab-abc*+^^*

14. Evaluate the following postfix expressions with a = 2.0 , b = 3.0, c = 4.0 , d = 5.0, e = 6.0

a. ebca^*+d-
6342^*+5-
                        4^2 = 16
                        3*16 = 48
			6+48 = 54
49			54-5 = 49

b. abc*d*-

234*5*-			

			3*4 = 12
			12*5 = 60
58			2-60 = 58

c. abc-/d*

234-/5*


		    3-4=-1
		    2/-1=-2
		    -2*5=-10

-10

15. For each of the following expression , first determine whether it is a valid postfix expression or not, 
if is valid, then evaluate it with the aid of a stack, for each case,what is the maximum depth of the 
stack involved? (Each number is seperated by space, and integer arithematic operations are assumed, 
^ represents the exponentiation.)

a. 1 3 + 4 / 5 2 3 ^ * + 2 3 2 ^ * - 

Stack: 3,1			1+3=4
Stack: 4,4			4/4=1
Stack: 3,2,5,1			2^3=8
Stack: 8,5,1			5*8=40
Stack: 40,1			1+40=41
Stack: 2,3,2,41			3^2=9
Stack: 9,2,31			2*9=18
Stack: 18,31			31-18=13
Stack: 13


b. 2 3 2 ^ ^ 4 2 ^ / 3 5  * 2 * -

Stack: 2,3,2			3^2=9
Stack: 9,2			2^9=512
Stack: 2,4,512			4^2=16
Stack: 16,512			512/16=32
Stack: 5,3,32			3*5=15
Stack: 2,15,32			15*2=30
Stack: 30,32			32-31=1
Stack: 1

c. 2 6 3 * 4 / 5 6 * 8 / - 

Stack: 3,6,2			6*3=18
Stack: 4,18,2			18/4=4.5
Stack: 6,5,4.5,2		5*6=30
Stack: 8,30,4.5,2		30/8=3.75
Stack: 3.75,4.5,2		3.75-4.5=-.75
Stack: -.75,2

not a valid postfix expression
