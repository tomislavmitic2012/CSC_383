<HTML><HEAD><TITLE>CSC383 Notes - wk1-2</TITLE></HEAD>
<BODY>
<CENTER>
<H2>Notes: Object Oriented Design <BR>Source: Goodrich &amp; Tamassia, Chapter 2 
</H2></CENTER>
<H4>Object-Oriented Design Goals </H4>
<UL>
  <LI>Robustness: capable of handling unexpected inputs 
  <P></P>
  <LI>Adaptability: (extensibility) able to grow in response to changing needs 
  <P></P>
  <LI>Reusability: ability to use the same code in different applications 
</LI></UL>
<H4>Object-Oriented Design Principles </H4>
<UL>
  <LI>Abstraction: distilling a complex entity into its essential parts. For 
  example defining an <I>integer</I> in terms of its basic operations (+, -, *, 
  /) rather than in terms of its implementation (#bits). An <I>abstract data 
  type (ADT)</I> defines a type in terms of its data (whole numbers) and 
  operations (+, -, *, /). An ADT's <I>interface</I> includes just those 
  operations. 
  <P></P>
  <LI>Encapsulation: (information hiding) Implementation details should be 
  hidden (<I>private</I>) within an object. For example, the algorithm for 
  integer multiplication is hidden. 
  <LI>Modularity: Dividing the components of a complex system into distinct, 
  functional modules. In an object-oriented language, the basic module is the 
  object (or the class). </LI></UL>
<H4>Inheritance and Polymorphism </H4>
<UL>
  <LI>Inheritance: A generic class (e.g., <TT>Number</TT>) can be specialized 
  into subclasses (e.g., <TT>Float</TT>, <TT>Integer</TT>). 
  <UL>
    <LI>subclass/superclass 
    <LI>derived class/base class 
    <LI>specialization/generalization 
    <LI>class inheritance diagram (See Figure 2.4, p. 65) 
    <LI><B>dynamic binding</B>: When a method is called by <I>o.m()</I>, Java 
    determines dynamically (at runtime) which method is represented by <I>m</I>. 
    If the method is contained in <I>o</I>'s class, it exexcutes that method. 
    Otherwise it searches upwards in <I>o</I>'s class hierarchy until it either 
    finds <I>m()</I> or, if not, it throws an exception. </LI></UL><PRE> public class S {
    protected int x;
    public void a();
    public void b();
    public void c();
 }

 public class T extends S {
    protected int y;
    public void d();
    public void e();
 }
</PRE>
  <P></P>
  <LI>Polymorphism: a method invocation, <I>o.m()</I> can refer to different 
  methods, depending on which type of object <I>o</I> refers to. Suppose we have 
  classes <TT>S</TT> and <TT>T</TT>, where <TT>T</TT> extends <TT>S</TT> and 
  such that both classes have a method <TT>m()</TT>. If <I>o</I> refers to a 
  <TT>T</TT> then <I>o.m()</I> is said to <I>override</I> the method </I>m()</I> 
  that was defined in <TT>S</TT>. If <I>o</I> refers to an <TT>S</TT> then 
  <I>o.m()</I> refers to the method </I>m()</I> that was defined in <TT>S</TT>. <PRE> public class T extends S {
    public void a();          // Overrides S.a()
 }


 S s  = new S();
 s.a();            // Refers to S.a()
 s = new T();
 s.a();            // Refers to T.a()
</PRE>
  <P></P>
  <LI>Overloading: method overloading refers to the case where a class contains 
  several methods with the same name but different <I>signatures</I>. 
  <P></P>
  <LI>Refinement Overriding: The subclass method adds code to the superclass 
  method. The code in the superclass is invoked using the <TT>super</TT> 
  keyword. <PRE>   void a() {
      super.a();   // Invoke superclass method
      // New code
   }
</PRE>
  <P></P>
  <LI>Replacement Overriding: The subclass method completely replaces the 
  superclass method (by not invoking it with <TT>super</TT>). <PRE>   void a() {
      // New code doesn't invoke superclass
   }
</PRE>
  <P></P>
  <LI>Constructors employ refinement overriding <B>by default</B>. </LI></UL>
<H4>Example: Numeric Progressions</H4>
<P>A <I>numeric progression</I> is a sequence of numbers where the next value in 
the sequence depends on one or more of the previous values. An <I>arithmetic 
progression</I> is one in which the next value is generated by addition. A 
<I>geometric progression</I> is one in which the next value is generated by 
multiplication. 
<P>To define a <I>generic progression</I> we must provide a way of defining the 
first value and a way of generating the current value. In this example, we begin 
with a generic <TT>Progression</TT> class, which contains the following 
variables and methods: <PRE>  first: first value of the progression
  cur:   current value of the progression
  firstValue(): resets the first value and returns it
  nextValue(): steps to the next value and returns it
  printProgression(): resets and prints the first n values
</PRE>
<P>Inheritance and polymorphism are used to define progression subclasses. 
Specifically, by creating new constructor methods for each subclass and by 
<I>overriding</I> the <TT>nextValue()</TT> method, we can define the 
<TT>ArithProgression</TT>, <TT>GeomProgression</TT>, and 
<TT>FibonacciProgression</TT> classes as specializations of the generic 
progression. 
<P>Link to following classes: 
<UL>
  <LI><A href="hw1/Progression.java">Progression.java</A> 

  <LI><A 
  href="hw1/ArithProgression.java">ArithProgression.java</A> 

  <LI><A 
  href="hw1/GeomProgression.java">GeomProgression.java</A> 

  <LI><A 
  href="hw1/FibonacciProgression.java">FibonacciProgression.java</A> 

  <LI><A 
  href="hw1/TestProgression.java">Tester.java</A> 
  </LI></UL>
<H4>Interfaces and Abstract Classes</H4>
<P>An <B>interface</B> is a class that contains <B>method signatures</B> without 
<B>method bodies</B>. 
<BLOCKQUOTE>
  <BLOCKQUOTE><PRE>/** Interface for objects that can be sold */
public interface Sellable {

  /** description of the object */
  public String description();

  /** list price in cents */
  public int listPrice();

  /** list price in cents */
  public int lowestPrice();
}

/** Interface for objects that can be transported */
public interface Transportable {

   /** weight in grams */
   public int weight();

   /** returns whether object is hazardous */
   public boolean isHazardous();
}

/** Class for photos that can be sold and transported */
public class Photograph implements Sellable, Transportable {
   private String descript;
   private int price;
   private boolean color; 
   private int weight;
   private boolean haz;

   public Photograph(String desc, int p, boolean c, int w, boolean h) {
       descript = desc;
       price = p;
       color = c;
       weight = w;
       haz = h;
   }

   public String description() { return descript; }
   public int listPrice() { return price; }
   public int lowestPrice() { return price/2; }
   public boolean isColor() { return color; }
   public int weight() { return weight; }
   public boolean isHazardous() { return haz; }
}
</PRE></BLOCKQUOTE></BLOCKQUOTE>
<H4>Multiple Inheritance</H4>
<P>The previous example is a case of <B>multiple inheritance</B>, the Photograph 
class inherits from both Transportable and Sellable. 
<P>Java only allows multiple inheritance with interfaces. A class can only 
extend one superclass. 
<H4>Casting</H4>
<P><B>Strong typing</B> means that all variables must be typed and methods must 
declare the types they expect and return. 
<P>An object's <B>primary type</B> is the type it has when it is 
<B>instantiated</B>. 
<BLOCKQUOTE>
  <BLOCKQUOTE><PRE>Number i = new Integer();  // i's primary type is Integer
</PRE></BLOCKQUOTE></BLOCKQUOTE>
<P>It is often necessary to convert one type to another type. 
<P><B>Widening conversion</B> occurs when an object of type T is converted to a 
wider type U where (1) U is a superclass of T, (2) U is a superinterface of 
interface T, or (3) U is an interface of class T. 
<P><B>Narrowing conversion</B> occurs when an object of type T is converted to a 
narrower type S where (1) S is a subclass of T, (2) S is a subinterface of 
interface T, or (3) S is a class that implements interface T. 
<P><B>Casting rule:</B> We can cast an object reference, <I>o</I>, of type T 
into a type S, provided that <I>o</I> refers to an object that is 
<B>actually</B> of type S. 
<BLOCKQUOTE>
  <BLOCKQUOTE><PRE>Number n;
Integer i;
n = new Integer(3);   // n's dynamic type is Integer
i = (Integer) n;      //  Ok. Since n is an Integer it can be cast into an Integer variable.
n = new Double(3.1);  // n is now a Double
i = (Integer) n;      // Illegal Cast Exception:  n is not an Integer.
</PRE></BLOCKQUOTE></BLOCKQUOTE>
<H4>Casting with Interfaces</H4>
<P>Interface variables some times require casts. 
<BLOCKQUOTE>
  <BLOCKQUOTE><PRE>// In this case a cast is needed to print out the price of a photograph
// because it is stored in a Transportable variable.

Transportable t = new Photograph("Building", 5, false, 1, false);
System.out.println("The price of that photograph is " + ((Sellable)t).listPrice());  // Cast ok
System.out.println("The price of that photograph is " + ((Photograph)t).listPrice()); // Cast ok
//System.out.println("The price of that photograph is " + t.listPrice());  // Syntax error--no such method
</PRE></BLOCKQUOTE></BLOCKQUOTE></BODY></HTML>
